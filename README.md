# Hyperion

> Of Hyperion we are told that he was the first to understand, by diligent attention and observation, the movement of both the sun and the moon and the other stars, and the seasons as well, in that they are caused by these bodies, and to make these facts known to others; and that for this reason he was called the father of these bodies, since he had begotten, so to speak, the speculation about them and their nature.    
>  â€” Diodorus Siculus (5.67.1)

Hyperion is a tool aiming at analysing Java test programs, to generate multiple similarity metrics. To this end, hyperion relies on [JBSE](https://github.com/pietrobraione/jbse) to carry out symbolic execution of JUnit test programs, generate prolog facts, and carry out multiple analyses on these facts.

## Dependencies

There are several dependencies to hyperion:

* JBSE (currently bundled in the project)
* z3
* SWI Prolog

The source is organized as a maven project, so running `mvn build` should be enough to get everything up and running.

`z3` is an external dependency, which should be available in the system path for the tool to correctly run. Similarly,
SWI Prolog must be manually installed in the system.

### Configuring integration with SWI Prolog

To interact with SWI Prolog, hyperion uses JPL. While java bindings are resolved through maven, there is the need to
let JPL know how to interact with SWI Prolog. To this end, some environmental variables should be set. Depending on your
OS, this configuration requires some care. You can refer the official deployment pages, depending on your OS:

* [Linux](https://jpl7.org/DeploymentLinux)
* [Windows](https://jpl7.org/DeploymentWindows)
* [Mac OS](https://jpl7.org/DeploymentMacos)


## Running

Hyperion can be run as:

```bash
java -cp target/hyperion-shaded-1.0-SNAPSHOT.jar it.cnr.saks.hyperion.Main <path to test classes> <path to SUT classes> [additional paths to add in classpath]
```

# Dev Notes

### Encoding of method invocations

Format for the Prolog facts `invokes` in files like [this one](src/test/resources/inspection-2020-12-03T11:33Z.pl):
```prolog
invokes(TestProgram, BranchingPointList, SeqNum, Caller, ProgramPoint, FrameEpoch, PathCondition, Callee, Parameters)
```

### Encoding of remote API invocations

Format for the Prolog facts `endpoint`:

```prolog
endpoint(TestProgram, Caller, HTTPMethod, URI)
```

It states that the method `Caller` of the test program `TestProgram` invokes the remote API identified by `URI` using the HTTP method `HTTPMethod`.
These facts can be generated by using the helper predicate `generate_and_assert_endpoints` described below.

## Playing with Prolog

To load `similarity_relations.pl`:

```prolog
consult('src/main/prolog/similarity_relations.pl').
```

To load `testing_similarity_relations.pl`:

```prolog
consult('src/main/prolog/testing_similarity_relations.pl').
```

which also loads `similarity_relations.pl`.

To get an execution trace `Trace` of the method annotated as `@Test` in the test program `TP`:

```prolog
trace(TP,Trace).
```
(`Trace` is a list of `invokes`).

To get a maximal sequence of direct method invocations `MSeq` performed by a caller `M` in the test program `TP`:

```prolog
invoke_sequence(TP,M,ISeq), invokes_callees(ISeq,MSeq).
```
(`ISeq` is a list of `invokes`).

To generate `endpoint` Prolog facts

```prolog
generate_and_assert_endpoints(EpSrc).
```

If `EpSrc=trace`, the `endpoint` facts will be generated from traces.
If `EpSrc=iseq`, the `endpoint` facts will be generated from sequences of method invocations.

To get a pair of similar test programs `TP1` and `TP2`:

```prolog
similar_tp(EpSrc,SimCr,TP1,TP2,Es1,Es2).
```
where:
* EpSrc specifies the source of the `endpoint` facts,
* SimCr specifies the criterion to evaluate similarity between `TP1` and `TP2` (it can be substituted for any of these values: `nonemptyEqSet`, `nonemptySubSet`, `nonemptyIntersection`),
* Es1 and Es2 are nonempty lists of `endpoint` facts generated from the `invokes` facts of `TP1` and `TP2`, respectively, that make the test programs similar.

To get the similarity score between two list of `endpoint` facts:

```prolog
similarity_score(SimCr,Es1,Es2,Score).
```

### Evaluating similarity of test programs

* Step 1. Load `testing_similarity_relations.pl`:

```prolog
consult('src/main/prolog/testing_similarity_relations.pl').
```

* Step 2. Load `rest _api_regex` facts representing regular expressions used to match API URIs (4th component of `endpoint` facts) in evaluating the similarity of `endpoint` facts:

```prolog
consult('src/test/resources/report/URI-regex-list.pl').
```

* Step 3. Run the following query to:
  - generate the `endpoint` facts from the execution traces (by using `generate_and_assert_endpoints(EpSrc)`),
  - evaluate similarity between test programs using the `nonemptyIntersection` criterion (by using `similar_tp(EpSrc,SimCr,TP1,TP2,Es1,Es2)`), and
  - compute the similarity score (by using `similarity_score(SimCr,Es1,Es2,Score)`).

```prolog
similarity_from_invokes_file('src/test/resources/report/inspection-invokes.pl',trace,nonemptyIntersection).
```

where `inspection-invokes.pl` is the dataset of `invokes` facts used to generate the `endpoint` facts. The above query generates two files:

- [similarEndpoints-trace-report.csv](src/test/resources/report/similarEndpoints-trace-report.csv), including the pairs of similar programs (3rd and 4th column) together with the corresponding score (5th column);

- [similarEndpoints-trace-report.txt](src/test/resources/report/similarEndpoints-trace-report.txt), including the pairs of similar programs together with the lists of `endpoint` facts `Es1` and `Es2` of `TP1` and `TP2`, respectively, that makes the two test programs similar.

## Wrapping @Before and @BeforeEach

To wrap @Before and @BeforeEach methods, we rely on Javassist. In particular, for each test class which is discovered
during the test program analysis, we keep track of every @Before method for each class.
We then dynamically generate a static method in a custom class (TestWrapper) which allocates an object of the test
class, invokes (in random order) all methods annotated as @Before, and then invokes the test program.
